--setup public favors tables, these can be accessed directly by users
--using id=6 to indicate that a user has been deleted to prevent issues

-- moving favors_user table here

create type favor_type as enum ('rides', 'academic', 'food');
--all user inputted information for favors
create table favors_user (
  f_id int generated by default as identity primary key,
  karma int not null,
  f_type favor_type not null,
  title text not null,
  description text not null,
  f_img_url text,
  edited boolean default false,

  constraint zero_karma check (karma > 0),
  constraint empty_title check (char_length(title) > 0),
  constraint empty_desc check (char_length(description) > 0)
);

create table comments (
  comment_id int generated by default as identity primary key,
  f_id int references public.favors_user on delete cascade not null,
  owner_id int default 6 references public.profiles on delete set default not null,
  comment text not null,
  reply_to int references public.comments,
  edited boolean default false,

  constraint empty_comment check (char_length(comment) > 0)
);

create table likes (
  f_id int references public.favors_user on delete cascade not null,
  owner_id int references public.profiles on delete cascade not null,
  primary key (f_id, owner_id)
);

create table reviews (
  f_id int references public.favors_user on delete cascade not null primary key,
  owner_id int default 6 references public.profiles on delete set default not null,
  review text not null,
  edited boolean default false,

  constraint empty_review check (char_length(review) > 0)
);


--RLS and policies
alter table public.comments enable row level security;
alter table public.likes enable row level security;
alter table public.reviews enable row level security;

create policy "Comments are viewable by everyone." on public.comments for select using (true);
create policy "Likes are viewable by everyone." on public.likes for select using (true);
create policy "Reviews are viewable by everyone" on public.reviews for select using (true);

create policy "User can insert own comment." on public.comments for insert
  with check (owner_id in (
    select id from public.profiles where auth.uid() = uid
  ));
create policy "User can insert own like." on public.likes for insert
  with check (owner_id in (
    select id from public.profiles where auth.uid() = uid
  ));
create policy "User can insert own review." on public.reviews for insert
  with check (owner_id in (
    select id from public.profiles where auth.uid() = uid
  ));

create policy "User can update own comment." on public.comments for update
  using (owner_id in (
    select id from public.profiles where auth.uid() = uid
  ));
--doesn't make sense to update likes
create policy "User can update own review." on public.reviews for update
  using (owner_id in (
    select id from public.profiles where auth.uid() = uid
  ));

--comments can be 'deleted' through an rpc call because the actual entry cannot be deleted
create policy "User can delete own like." on public.likes for delete
  using (owner_id in (
    select id from public.profiles where auth.uid() = uid
  ));
--reviews cannot be deleted

--setup private favors tables
--using id=6 to indicate that a user has been deleted to prevent issues

--types
create type favor_status as enum ('open', 'closed', 'in progress', 'in review');

--all server-inputted information for favors
create table private.favors_server (
  f_id int references public.favors_user on delete cascade not null primary key,
  poster_id int default 6 references public.profiles on delete set default not null,
  completer_id int default 6 references public.profiles on delete set default not null,
  posted_at timestamp with time zone not null,
  completed_at timestamp with time zone,
  reviewed_at timestamp with time zone,
  f_status favor_status not null,

  constraint same_user check (poster_id != completer_id or poster_id = 6)
);

--grant public access through postgres functions
--grant access to schema
grant usage on schema private to public;
--grant access to table
grant select, insert, update(completer_id, completed_at, reviewed_at, f_status), delete on private.favors_server to public;

--rls policies for favors
alter table public.favors_user enable row level security;
alter table private.favors_server enable row level security;

create policy "User info for favors are viewable." on public.favors_user for select using (true);
create policy "Server info for favors are viewable." on private.favors_server for select using (true);

create policy "Anyone can insert onto favors_user." on public.favors_user for insert
  with check (true);
-- can only do this because the private schema is not accessible through the API
create policy "User can insert own server info" on private.favors_server for insert
  with check (poster_id in (
    select id from public.profiles where auth.uid() = uid
  ));

create policy "Poster can update own user favor info." on public.favors_user for update
  using (f_id in (
    select s.f_id from public.profiles as p, private.favors_server as s
    where auth.uid() = p.uid and p.id = s.poster_id
  ));
-- either 1. the poster is changing info, 2. there is no completer so completer_id = 6, or 3. the completer is changing info
create policy "Poster and completer can update server favor info." on private.favors_server for update
  using ((poster_id in (
    select id from public.profiles where auth.uid() = uid
  )) or (completer_id = 6) or (completer_id in (
    select id from public.profiles where auth.uid() = uid
  )));

create policy "User can delete own favor user info IF f_status is open" on public.favors_user for delete
  using ((f_id in (
    select s.f_id from public.profiles as p, private.favors_server as s
    where auth.uid() = p.uid and p.id = s.poster_id
  )) and ('open' in (
    select f_status from private.favors_server as s where s.f_id = f_id
  )));

create policy "User can delete own favor server info IF f_status is open" on private.favors_server for delete
  using ((poster_id in (
    select id from public.profiles where auth.uid() = uid
  )) and (f_status = 'open'));