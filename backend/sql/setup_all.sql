-- Create a table for public profiles
create table profiles (
  id int generated by default as identity primary key,
  uid uuid references auth.users on delete cascade not null,
  updated_at timestamp with time zone not null,
  full_name text not null,
  avatar_url text not null,

  constraint full_name_length check (char_length(full_name) > 0)
);
-- Set up Row Level Security (RLS)
-- See https://supabase.com/docs/guides/auth/row-level-security for more details.
alter table profiles
  enable row level security;

create policy "Public profiles are viewable by everyone." on profiles
  for select using (true);

create policy "Users can update own profile." on profiles
  for update using (auth.uid() = uid);

-- This trigger automatically creates a profile entry when a new user signs up via Supabase Auth.
-- See https://supabase.com/docs/guides/auth/managing-user-data#using-triggers for more details.

--Add existing rows from auth.users
do
$$
declare
  row record;
begin
  for row in select id, created_at, raw_user_meta_data
    from auth.users 
    order by raw_user_meta_data->>'full_name'
  loop 
    insert into public.profiles (uid, updated_at, full_name, avatar_url)
    values (row.id, row.created_at, row.raw_user_meta_data->>'full_name', 'TODO: add default avatar url');
  end loop;
end;
$$;

create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (uid, updated_at, full_name, avatar_url)
  values (new.id,
          new.created_at,
          new.raw_user_meta_data->>'full_name',
          'TODO: add default avatar url');
  return new;
end;
$$ language plpgsql security definer;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

--setup private favors tables
--using id=6 to indicate that a user has been deleted to prevent issues

--types
create type favor_type as enum ('rides', 'academic', 'food');
create type favor_status as enum ('open', 'closed', 'in progress', 'in review');

create table private.favors_transactions (
  f_id int generated by default as identity primary key,
  poster_id int default 6 references public.profiles on delete set default not null,
  completer_id int default 6 references public.profiles on delete set default not null,

  constraint same_user check (poster_id != completer_id or poster_id = 6)
);

--all user inputted information for favors
create table private.favors_user (
  f_id int references private.favors_transactions on delete cascade not null primary key,
  num_karma int not null,
  f_type favor_type not null,
  title text not null,
  description text not null,
  f_img_url text,
  edited boolean default false,

  constraint zero_karma check (num_karma > 0),
  constraint empty_title check (char_length(title) > 0),
  constraint empty_desc check (char_length(description) > 0)
);

--all server-inputted information for favors
create table private.favors_server (
  f_id int references private.favors_transactions on delete cascade not null primary key,
  posted_at timestamp with time zone not null,
  completed_at timestamp with time zone,
  reviewed_at timestamp with time zone,
  f_status favor_status not null
);

--rls policies
alter table private.favors_transactions enable row level security;
alter table private.favors_user enable row level security;
alter table private.favors_server enable row level security;

create policy "Transactions are viewable." on private.favors_transactions for select using (true);
create policy "User info for favors are viewable." on private.favors_user for select using (true);
create policy "Server info for favors are viewable." on private.favors_server for select using (true);

create policy "User can insert own transaction" on private.favors_transactions for insert
  with check (poster_id in (
    select id from public.profiles where auth.uid() = uid
  ));
create policy "User can insert own user favor info." on private.favors_user for insert
  with check (f_id in (
    select t.f_id from public.profiles as p, private.favors_transactions as t
    where auth.uid() = p.uid and p.id = t.poster_id
  ));
create policy "User can insert own server info" on private.favors_server for insert
  with check (f_id in (
    select t.f_id from public.profiles as p, private.favors_transactions as t
    where auth.uid() = p.uid and p.id = t.poster_id
  ));

create policy "Completer can update transaction with own id." on private.favors_transactions for update
  using ((completer_id = 6) or (completer_id in (
    select id from public.profiles where auth.uid() = uid
  )))
  with check ((completer_id = 6) or (completer_id in (
    select id from public.profiles where auth.uid() = uid
  )));
  
create policy "Poster can update user favor info." on private.favors_user for update
  using (f_id in (
    select t.f_id from public.profiles as p, private.favors_transactions as t
    where auth.uid() = p.uid and p.id = t.poster_id
  ));

create policy "Poster and completer can update server favor info." on private.favors_server for update
  using (f_id in (
    select t.f_id from public.profiles as p, private.favors_transactions as t
    where auth.uid() = p.uid and (p.id = t.poster_id or p.id = t.completer_id)
  ));

create policy "User can delete own transaction IF f_status is open" on private.favors_transactions for delete
  using ((poster_id in (
    select id from public.profiles where auth.uid() = uid
  )) and ('open' in (
    select f_status from private.favors_server as f where f.f_id = f_id 
  )));

create policy "User can delete own favor user info IF f_status is open" on private.favors_user for delete
  using ((f_id in (
    select t.f_id from public.profiles as p, private.favors_transactions as t
    where auth.uid() = p.uid and (p.id = t.poster_id or p.id = t.completer_id)
  )) and ('open' in (
    select f_status from private.favors_server as f where f.f_id = f_id 
  )));

create policy "User can delete own favor server info IF f_status is open" on private.favors_server for delete
  using ((f_id in (
    select t.f_id from public.profiles as p, private.favors_transactions as t
    where auth.uid() = p.uid and (p.id = t.poster_id or p.id = t.completer_id)
  )) and ('open' in (
    select f_status from private.favors_server as f where f.f_id = f_id 
  )));


--grant public access through postgres functions
--grant access to schema
grant usage on schema private to public;
--grant access to tables
grant select, insert, update(completer_id), delete on private.favors_transactions to public;

grant select, insert, update(completed_at, reviewed_at, f_status), delete on private.favors_server to public;

grant select, insert, update, delete on private.favors_user to public;

--setup public favors tables, these can be accessed directly by users
--using id=6 to indicate that a user has been deleted to prevent issues

create table comments (
  comment_id int generated by default as identity primary key,
  f_id int references private.favors_user on delete cascade not null,
  owner_id int default 6 references public.profiles on delete set default not null,
  comment text not null,
  reply_to int references public.comments,
  edited boolean default false,

  constraint empty_comment check (char_length(comment) > 0)
);

create table likes (
  f_id int references private.favors_user on delete cascade not null,
  owner_id int references public.profiles on delete cascade not null,
  primary key (f_id, owner_id)
);

create table reviews (
  f_id int references private.favors_user on delete cascade not null primary key,
  owner_id int default 6 references public.profiles on delete set default not null,
  review text not null,
  edited boolean default false,

  constraint empty_review check (char_length(review) > 0)
);


--RLS and policies
alter table public.comments enable row level security;
alter table public.likes enable row level security;
alter table public.reviews enable row level security;

create policy "Comments are viewable by everyone." on public.comments for select using (true);
create policy "Likes are viewable by everyone." on public.likes for select using (true);
create policy "Reviews are viewable by everyone" on public.reviews for select using (true);

create policy "User can insert own comment." on public.comments for insert
  with check (owner_id in (
    select id from public.profiles where auth.uid() = uid
  ));
create policy "User can insert own like." on public.likes for insert
  with check (owner_id in (
    select id from public.profiles where auth.uid() = uid
  ));
create policy "User can insert own review." on public.reviews for insert
  with check (owner_id in (
    select id from public.profiles where auth.uid() = uid
  ));

create policy "User can update own comment." on public.comments for update
  using (owner_id in (
    select id from public.profiles where auth.uid() = uid
  ));
--doesn't make sense to update likes
create policy "User can update own review." on public.reviews for update
  using (owner_id in (
    select id from public.profiles where auth.uid() = uid
  ));

--comments can be 'deleted' through an rpc call because the actual entry cannot be deleted
create policy "User can delete own like." on public.likes for delete
  using (owner_id in (
    select id from public.profiles where auth.uid() = uid
  ));
--reviews cannot be deleted

--returns the amount of karma each user has
create or replace view user_karma as
--1000 is the initial amount of karma each user has, the current amount of karma they have is calculated from this
select id, 1000 + sum(temp.num_karma) as num_karma
from (
  --since poster loses money
  (select t.poster_id as id, (-1 * sum(f.num_karma)) as num_karma
  from private.favors_transactions as t, private.favors_user as f
  where t.f_id = f.f_id
  group by t.poster_id)
  union all
  (select t.completer_id as id, sum(f.num_karma) as num_karma
  from private.favors_transactions as t, private.favors_user as f
  where t.f_id = f.f_id
  group by t.completer_id)
) as temp group by id;

create or replace function create_favor(num_karma int,
                                        f_type favor_type,
                                        title text,
                                        description text,
                                        f_img_url text) returns json as $$
declare
  new_f_id int default 6;
begin
  insert into private.favors_transactions(f_id, poster_id)
  values (DEFAULT, (select id from public.profiles where auth.uid() = uid)) returning f_id into new_f_id;

  insert into private.favors_user(f_id, num_karma, f_type, title, description, f_img_url)
  values (new_f_id, num_karma, f_type, title, description, f_img_url);

  insert into private.favors_server(f_id, posted_at, f_status)
  values (new_f_id, now(), 'open');

  return json_build_object('f_id', new_f_id);

  exception when others then 
    raise exception 'Error creating favor'
    using detail = sqlerrm,
          hint = sqlstate;

end;
$$ language plpgsql;