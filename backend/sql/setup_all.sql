-- Create a table for public profiles
create table profiles (
  id int generated by default as identity primary key,
  uid uuid references auth.users on delete cascade not null,
  full_name text not null,
  pronouns text,
  about_me text,
  avatar_url text not null,
  updated_at timestamp with time zone not null,
  karma int default 1000,
  helped int default 0,

  constraint full_name_length check (char_length(full_name) > 0)
);
-- Set up Row Level Security (RLS)
-- See https://supabase.com/docs/guides/auth/row-level-security for more details.
alter table profiles
  enable row level security;

create policy "Public profiles are viewable by everyone." on profiles
  for select using (true);

-- remove edit access to karma and helped
revoke update on profiles from public;
grant update(full_name, pronouns, about_me, avatar_url, updated_at) on profiles to public;

create policy "Users can update own profile except karma and helped." on profiles
  for update using (auth.uid() = uid);

-- This trigger automatically creates a profile entry when a new user signs up via Supabase Auth.
-- See https://supabase.com/docs/guides/auth/managing-user-data#using-triggers for more details.

--Add existing rows from auth.users
do
$$
declare
  row record;
begin
  for row in select id, created_at, raw_user_meta_data
    from auth.users 
    order by raw_user_meta_data->>'full_name'
  loop 
    insert into public.profiles (uid, updated_at, full_name, avatar_url)
    values (row.id, row.created_at, row.raw_user_meta_data->>'full_name', 'TODO: add default avatar url');
  end loop;
end;
$$;

create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (uid, updated_at, full_name, avatar_url)
  values (new.id,
          new.created_at,
          new.raw_user_meta_data->>'full_name',
          'TODO: add default avatar url');
  return new;
end;
$$ language plpgsql security definer;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

--setup public favors tables, these can be accessed directly by users
--using id=6 to indicate that a user has been deleted to prevent issues

-- moving favors_user table here

create type favor_type as enum ('rides', 'academic', 'food');
--all user inputted information for favors
create table favors_user (
  f_id int generated by default as identity primary key,
  karma int not null,
  f_type favor_type not null,
  title text not null,
  description text not null,
  f_img_url text,
  edited boolean default false,

  constraint zero_karma check (karma > 0),
  constraint empty_title check (char_length(title) > 0),
  constraint empty_desc check (char_length(description) > 0)
);

create table comments (
  comment_id int generated by default as identity primary key,
  f_id int references public.favors_user on delete cascade not null,
  owner_id int default 6 references public.profiles on delete set default not null,
  comment text not null,
  reply_to int references public.comments,
  edited boolean default false,

  constraint empty_comment check (char_length(comment) > 0)
);

create table likes (
  f_id int references public.favors_user on delete cascade not null,
  owner_id int references public.profiles on delete cascade not null,
  primary key (f_id, owner_id)
);

create table reviews (
  f_id int references public.favors_user on delete cascade not null primary key,
  owner_id int default 6 references public.profiles on delete set default not null,
  review text not null,
  edited boolean default false,

  constraint empty_review check (char_length(review) > 0)
);


--RLS and policies
alter table public.comments enable row level security;
alter table public.likes enable row level security;
alter table public.reviews enable row level security;

create policy "Comments are viewable by everyone." on public.comments for select using (true);
create policy "Likes are viewable by everyone." on public.likes for select using (true);
create policy "Reviews are viewable by everyone" on public.reviews for select using (true);

create policy "User can insert own comment." on public.comments for insert
  with check (owner_id in (
    select id from public.profiles where auth.uid() = uid
  ));
create policy "User can insert own like." on public.likes for insert
  with check (owner_id in (
    select id from public.profiles where auth.uid() = uid
  ));
create policy "User can insert own review." on public.reviews for insert
  with check (owner_id in (
    select id from public.profiles where auth.uid() = uid
  ));

create policy "User can update own comment." on public.comments for update
  using (owner_id in (
    select id from public.profiles where auth.uid() = uid
  ));
--doesn't make sense to update likes
create policy "User can update own review." on public.reviews for update
  using (owner_id in (
    select id from public.profiles where auth.uid() = uid
  ));

--comments can be 'deleted' through an rpc call because the actual entry cannot be deleted
create policy "User can delete own like." on public.likes for delete
  using (owner_id in (
    select id from public.profiles where auth.uid() = uid
  ));
--reviews cannot be deleted

--setup private favors tables
--using id=6 to indicate that a user has been deleted to prevent issues

--types
create type favor_status as enum ('open', 'closed', 'in progress', 'in review');

--all server-inputted information for favors
create table private.favors_server (
  f_id int references public.favors_user on delete cascade not null primary key,
  poster_id int default 6 references public.profiles on delete set default not null,
  completer_id int default 6 references public.profiles on delete set default not null,
  posted_at timestamp with time zone not null,
  completed_at timestamp with time zone,
  reviewed_at timestamp with time zone,
  f_status favor_status not null,

  constraint same_user check (poster_id != completer_id or poster_id = 6)
);

--grant public access through postgres functions
--grant access to schema
grant usage on schema private to public;
--grant access to table
grant select, insert, update(completer_id, completed_at, reviewed_at, f_status), delete on private.favors_server to public;

--rls policies for favors
alter table public.favors_user enable row level security;
alter table private.favors_server enable row level security;

create policy "User info for favors are viewable." on public.favors_user for select using (true);
create policy "Server info for favors are viewable." on private.favors_server for select using (true);

create policy "Anyone can insert onto favors_user." on public.favors_user for insert
  with check (true);
-- can only do this because the private schema is not accessible through the API
create policy "User can insert own server info" on private.favors_server for insert
  with check (poster_id in (
    select id from public.profiles where auth.uid() = uid
  ));

create policy "Poster can update own user favor info." on public.favors_user for update
  using (f_id in (
    select s.f_id from public.profiles as p, private.favors_server as s
    where auth.uid() = p.uid and p.id = s.poster_id
  ));
-- either 1. the poster is changing info, 2. there is no completer so completer_id = 6, or 3. the completer is changing info
create policy "Poster and completer can update server favor info." on private.favors_server for update
  using ((poster_id in (
    select id from public.profiles where auth.uid() = uid
  )) or (completer_id = 6) or (completer_id in (
    select id from public.profiles where auth.uid() = uid
  )));

create policy "User can delete own favor user info IF f_status is open" on public.favors_user for delete
  using ((f_id in (
    select s.f_id from public.profiles as p, private.favors_server as s
    where auth.uid() = p.uid and p.id = s.poster_id
  )) and ('open' in (
    select f_status from private.favors_server as s where s.f_id = f_id
  )));

create policy "User can delete own favor server info IF f_status is open" on private.favors_server for delete
  using ((poster_id in (
    select id from public.profiles where auth.uid() = uid
  )) and (f_status = 'open'));
